<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>计网链路层模型可视化（小课堂）</title>
    <link href="https://fonts.googleapis.com/css?family=Quicksand:400,700" rel="stylesheet">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
    <link rel="stylesheet" href="css/style-index.css">
    <style>
        canvas{
            z-index: -100;
        }

    html, body {

    height: 100%;

    overflow: hidden;

    }

    </style>

</head>
<body>

<h1>计网链路层模型可视化（小课堂）</h1>
<p>本站为想要了解计算机网络链路层模型的一般学生，以及想要直观理解链路层模型的计算机专业学生提供一个可视化的动画展示与教学。</p>
<p>我们将以一个虚拟的卡通故事为主线，融合动画演示，来解释每一个链路层的模型。</p>
<p>（程序猿和程序狗因为老板的蛮横的命令，在北京的程序猿必须给在上海的程序狗送砖头过去才行，他们需要保证不出任何差错地完成任务，还需要满足老板日益增加的效率需求。）</p>

<!--<p><input type="checkbox" id="accordion-toggle"><label for="accordion-toggle">Keep animations but remove auto-collapse effect </label></p>-->
<!--<canvas id="cas" position : absolute;z-index : -1;></canvas>-->
<div class="container collapse">
    <details>
        <summary>乌托邦式的单工协议</summary>
        <div class="details-wrapper">
            <div class="details-styling" onclick="navigate_1()">
                <p>这是对于网络传输理想化的模型，认为在传输过程中，不会出现任何通信错误，即所有帧都可以不发生任何错误地按序抵达接收方。</p>
                <p>在这种情况下，发送方只需要一个接一个的发送自己的帧，接收方只需要负责接收，不需要回传确认帧进行确认。</p>
            </div>
        </div>
    </details>
    <details>
        <summary>无错信道上的单工停-等协议</summary>
        <div class="details-wrapper">
            <div class="details-styling" onclick="navigate_2()">
                <p>这个协议在之前的理想化模型的基础上，引入了确认帧的机制。每当接收方收到一帧，就马上发送一帧确认帧用于确认。</p>
                <p>发送方在发送一帧之后，便设定一个定时器，只有在收到确认帧的情况下，才能继续下一帧的发送，而如果没有收到确认帧，就一直等到定时器超时，然后重新发送该帧。</p>
                <p>设置定时器是为了避免在确认帧或自己发送的帧超时的情况下，不会陷入一直在等待的死锁情况。</p>
            </div>
        </div>
    </details>
    <details>
        <summary>有错停等</summary>
        <div class="details-wrapper">
            <div class="details-styling" onclick="navigate_3()">
                <p>这个协议同样是在之前的理想化模型的基础上，引入了确认帧的机制。每当接收方收到一帧，就马上发送一帧确认帧用于确认。</p>
                <p>与上一种协议的主要区别，在于它是一个双工信道，也就是说实际情况下，接收方也可以给发送方发送数据帧，而确认帧有时可以携带在数据帧中一起发送，可以少发送一些帧</p>
            </div>
        </div>
    </details>
    <details>
        <summary>一位滑动窗口协议</summary>
        <div class="details-wrapper">
            <div class="details-styling" onclick="navigate_4()">
                <p>在有错停等的基础上，又有了进一步的改进。发送方发送所有在发送窗口中的帧，而接收方会接收所有在接收窗口的帧。双方会在传输之前对窗口大小进行协商接收窗口取决于接收方的缓存大小，发送窗口则用于控制传输速率。</p>
                <p>在一位滑动窗口中，接收方与发送方的窗口大小均为一，这种情况与之前的有错停等基本相同，但是内在的思想不同。这种窗口的思想可以通过调整窗口大小，达到提高或控制传输效率等作用。</p>
            </div>
        </div>
    </details>
    <details>
        <summary>回退N协议</summary>
        <div class="details-wrapper">
            <div class="details-styling" onclick="navigate_5()">
                <p>在一位活动窗口的基础上进行了改进。在这种情况下，发送方的窗口大小为n(n>1)，而接收方的窗口大小为1.</p>
                <p>发送方一次性将窗口内的帧全部发送，并在收到确认帧后可以向后移动发送窗口。接收方每接收到正确的帧，也向后移动一位接收窗口。在发送方对确认帧的处理方法中，可以使用累计确认来移动发送窗口。</p>
                <p>之所以叫做回退N，是由于发送方对于定时器超时的处理方法导致的。因为一次会将发送窗口内的所有帧发送出去，而当正确的帧出现错误时，接收方会丢弃所有其他的帧，发送方因此在超时后需要重新将发送窗口内的所有帧全部重发一遍。</p>
            </div>
        </div>
    </details>
    <details>
        <summary>选择回传协议</summary>
        <div class="details-wrapper">
            <div class="details-styling" onclick="navigate_6()">
                <p>在回退N协议的基础上进行了改进。在这种情况下，发送方的窗口大小为n(n>1)，而接收方的窗口大小为m(m>1).</p>
                <p>发送方一次性将窗口内的帧全部发送，并在收到确认帧后可以向后移动发送窗口。接收方会接收处在接收窗口内的所有帧，当不是按照顺序到达时，会将帧缓存起来，等待所有帧按照顺序到达后再转交给网络层。</p>
                <p>对于发送方，当发送出现错误的情况，不需要再重发所有的帧，而只需要重发出现错误的帧即可。对于接收方，由于会接收非按序到达的帧，因此不能再使用累计确认。相反，使用否定确认通知发送方重发错误的帧。</p>
            </div>
        </div>
    </details>
</div>

<p>点击文本区域即可前往动画演示。</p>
<script>

    var canvas = document.getElementById("cas");

    var ctx = canvas.getContext("2d");




    resize();

    window.onresize = resize;




    function resize() {

    canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

    canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

    }




    var RAF = (function() {

    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {

    window.setTimeout(callback, 1000 / 60);

    };

    })();




    // 鼠标活动时，获取鼠标坐标

    var warea = {x: null, y: null, max: 20000};

    window.onmousemove = function(e) {

    e = e || window.event;




    warea.x = e.clientX;

    warea.y = e.clientY;

    };

    window.onmouseout = function(e) {

    warea.x = null;

    warea.y = null;

    };




    // 添加粒子

    // x，y为粒子坐标，xa, ya为粒子xy轴加速度，max为连线的最大距离

    var dots = [];

    for (var i = 0; i < 300; i++) {

    var x = Math.random() * canvas.width;

    var y = Math.random() * canvas.height;

    var xa = Math.random() * 2 - 1;

    var ya = Math.random() * 2 - 1;




    dots.push({

    x: x,

    y: y,

    xa: xa,

    ya: ya,

    max: 6000

    })

    }




    // 延迟100秒开始执行动画，如果立即执行有时位置计算会出错

    setTimeout(function() {

    animate();

    }, 100);




    // 每一帧循环的逻辑

    function animate() {

    ctx.clearRect(0, 0, canvas.width, canvas.height);




    // 将鼠标坐标添加进去，产生一个用于比对距离的点数组

    var ndots = [warea].concat(dots);




    dots.forEach(function(dot) {




    // 粒子位移

    dot.x += dot.xa;

    dot.y += dot.ya;




    // 遇到边界将加速度反向

    dot.xa *= (dot.x > canvas.width || dot.x < 0) ? -1 : 1;

    dot.ya *= (dot.y > canvas.height || dot.y < 0) ? -1 : 1;




    // 绘制点

    ctx.fillRect(dot.x - 0.5, dot.y - 0.5, 1, 1);




    // 循环比对粒子间的距离

    for (var i = 0; i < ndots.length; i++) {

    var d2 = ndots[i];




    if (dot === d2 || d2.x === null || d2.y === null) continue;




    var xc = dot.x - d2.x;

    var yc = dot.y - d2.y;




    // 两个粒子之间的距离

    var dis = xc * xc + yc * yc;




    // 距离比

    var ratio;




    // 如果两个粒子之间的距离小于粒子对象的max值，则在两个粒子间画线

    if (dis < d2.max) {




    // 如果是鼠标，则让粒子向鼠标的位置移动

    if (d2 === warea && dis > (d2.max / 2)) {

    dot.x -= xc * 0.03;

    dot.y -= yc * 0.03;

    }




    // 计算距离比

    ratio = (d2.max - dis) / d2.max;




    // 画线

    ctx.beginPath();

    ctx.lineWidth = ratio / 2;

    ctx.strokeStyle = 'rgba(0,0,0,' + (ratio + 0.2) + ')';

    ctx.moveTo(dot.x, dot.y);

    ctx.lineTo(d2.x, d2.y);

    ctx.stroke();

    }

    }




    // 将已经计算过的粒子从数组中删除

    ndots.splice(ndots.indexOf(dot), 1);

    });




    RAF(animate);

    }

    </script>

<script  src="js/index.js"></script>
<script src="js/navigate.js"></script>
<script src="js/background.js"></script>

</body>
</html>